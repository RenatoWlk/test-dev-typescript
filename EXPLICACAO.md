## Como desenvolveu a API.

Primeiramente, li todas as etapas do desafio e procurei entender a estrutura do projeto. Por já ter feito um projeto com nodejs, comecei pelo server, onde comecei buscando o projeto que já tinha feito juntamente com pesquisas de implementações básicas de Express em Typescript. 
Após isso defini as rotas descritas, criando o router, criando duas funções assincronas que serão utilizadas na rota e definindo as duas rotas get e ligando elas às funções criadas, novamente utilizando o projeto que já tinha feito e pesquisas. 
Depois na parte de serviço, pensei em criar uma classe para Pokemon, que conteria seus dados e as funções de conversão, cálculo de IMC e categorização, mas decidi usar uma funcionalidade do typescript e fiz uma interface de Pokemon, e fiz as funções de conversão, cálculo e categorização. Por serem simples já implementei a lógica delas rapidamente, e fiz uma função chamada processPokemon, que pega os dados recebidos de nome, altura e peso, converte todos para as medidas solicitadas, faz o cálculo de IMC, faz a categorização e retorna um Pokemon no formato pedido. 
Em seguida fiz as duas funções que iriam realizar o consumo da Pokeapi, com a primeira sendo sem parâmetros e retornando uma lista de Pokemon, e a segunda com o parâmetro de nome e retornando um único Pokemon. Defini as URLs da pokeapi que serão utilizadas dentro das funções, fiz o try catch básico e peguei a resposta delas utilizando o axios, decidi utilizar axios por já ter conhecimento e ser mais fácil de trabalhar. A segunda função, por ser mais simples, já implementei logo, pois precisava somente processar os dados recebidos da pokeapi em um Pokemon, utilizando a função que foi criada anteriormente processPokemon. A primeira função era mais complexa, pois vi que a url da pokeapi retornava os pokemons com somente o nome e a url dos detalhes do pokemon, e seria preciso realizar um get nessa url para obter seus detalhes, portanto criei uma lista de Pokemon vazia, e fiz um laço que passa por todos os resultados que a pokeapi oferece, no caso os nomes dos pokemons e as urls dos seus detalhes, e fiz um get nessas urls que me dá os detalhes deles, depois processa esses dados dos detalhes com a função processPokemon e guarda como um Pokemon, e coloca esse Pokemon na lista de Pokemon, ao final retorna essa lista.
Posteriormente voltei para as rotas, importei as funções feitas que consomem a pokeapi e fiz a lógica das duas funções. A primeira é a que é chamada quando há uma requisição para /pokemons e a segunda quando há uma requisição para /pokemons/:name. Ambas recebem uma requisição e uma resposta e tem try catch para tratar erros apropriadamente. Na primeira criei uma constante para receber a lista de pokemons da função importada do serviço e defino a resposta como um json dessa lista, e caso encontre algum erro defini como resposta o status 500 de internal server error. Na segunda, como há requisição, pego o parâmetro name da requisição e faço a mesma coisa que a anterior, porém passando como parâmetro para a função importada do serviço o nome obtido na requisição, e guardo o pokemon resultante numa constante e defino a resposta como um json desse pokemon, e no tratamento de erro defini como resposta o status 404 not found, pois o nome do pokemon dado não foi encontrado.
Por fim, no servidor importei as rotas e defini o uso das rotas criadas através de /api, por exemplo /api/pokemons ou /api/pokemons/luxio.
Obtive alguns problemas ao desenvolver, por exemplo erro de sintaxes, parâmetro de name diferente do esperado, pequenos erros utilizando axios, configuração do typescript, mas todos foram solucionados rapidamente com pesquisas e por conta própria.

## Como realizou as conversões e o cálculo do IMC.

Criei as conversões e o cálculo do IMC logo de inicio, quando estava estruturando os arquivos e o que iria conter em cada um deles.
Comecei fazendo funções para cada uma das conversões, cada função recebe o valor a ser convertido e retorna o valor convertido, logo após fiz o cálculo do IMC que recebe peso e altura e retorna o IMC, e por último a categorização do IMC, que recebe apenas o IMC, verifica qual faixa está e retorna uma string dizendo se é leve, médio ou pesado.
Fiz dessa forma para facilitar a leitura do código e futuras manutenções.

## Quais foram os principais desafios encontrados.

- **Não conhecimento de Typescript:** quando comecei não conhecia a linguagem, utilizei de algumas pesquisas e um prompt no ChatGPT para entender melhor, depois de alguns minutos entendi que é extremamente parecido com Javascript, as vantagens da linguagem e como utilizá-la. Sendo assim depois de me situar melhor foi fácil e intuitivo sua utilização.
- **Configuração do Typescript:** após estruturar os arquivos, tentei debugar e me deparei com um erro, após ler o erro e fazer o que se pedia no Warning, o mesmo erro apareceu sem o Warning, procurei mais sobre o erro e percebi que poderia ser de má configuração do ts, e para resolver busquei sobre como configurar corretamente o ts e consegui consertar.
- **Requisições:** encontrei alguns erros enquanto fazia as requisições, um deles de lógica na parte de tratar os dados recebidos da pokeapi no endpoint /pokemons e o resto alguns erros de código por estar me baseando no meu conhecimento de Javascript para fazer e ser levemente diferente algumas coisas em Typescript, para resolvê-los utilizei logs em partes cruciais do código e pesquisas rápidas sobre Typescript.